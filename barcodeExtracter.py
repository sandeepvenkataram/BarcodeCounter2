###########################################################################
# January 26 2021
# Sandeep Venkataram, PhD.
# Postdoctoral Scholar, Kryazhimskiy Lab, 
# UCSD Division of Biological Sciences
# barcodeMapper.py 
# 
# This software is designed to extract and map barcodes from FASTA files 
# that are typically generated by Sanger sequencing
# It can accept arbitrary barcode locus designs, with arbitrary orientation 
# relative to the sequencing file. 
# 
# 
# 
# Dependencies:
#  Python 3
#  BioPython
#  BLAST suite
#  bwa (recommended) or bowtie2
#  linux environment for shell scripting (grep and cut)
# 
# Execution command for sample data
#	python3 barcodeMapper.py -templateSeq ../BCCounterTesting/sequenceTemplate.txt -inputFasta ../BCCounterTesting/inputFile.fasta
#
###########################################################################


import argparse
from Bio.Seq import Seq
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from collections import namedtuple
from pathlib import Path
import csv
#from __future__ import division
import fileinput
import glob
import gzip
import itertools as IT
import os
import random
import re
import sys
import subprocess



###########################################################################
## Global Variables
###########################################################################

sampleArray = []
indexToSampleMap = {}
templateSeqLengthsDict = {}
templateSeqArray = [] #one to two inner arrays, describing the template corresponding to each read
templateSeqLengthsArray = [] #one to two inner arrays, describing the lengths of each feature in the template seq array
validFeatureTypes = {"X" : "BC"}
validFeatureCounts = {"X" : 0}
usedFastqFiles = []
constantRegionFastaFilenames = [] # same dimensions as templateSeqArray
constantRegionNames = [] # same dimensions as templateSeqArray
allConstRegionsFileName = "allCRs.fasta"
maxNInReads = 3
fileBufferSize = 100000 #make sure we aren't constantly accessing the disk but small enough to reasonably keep in memory
expectedBarcodeLength = 0

#Blast parameters
constantRegionsBlastParams = ["-word_size", "6","-outfmt","6","-evalue","1E0"]

###########################################################################
## Import arguments and define help output
###########################################################################


cmdLineArgParser = argparse.ArgumentParser(description="Process FASTA sequences to extract and map barcodes. Make sure there are no spaces in any file names or directory paths, the program will not work otherwise. \n\nGenerated Files:\n\n")
cmdLineArgParser.add_argument("-templateSeq", dest="templateSeqFile", help="Template sequence of amplicon locus. This file contains a single line with standard DNA bases. UMI (unique molecular identifier) sequences are coded as U, multiplexing indices are coded as D and barcode loci coded as X. If these features have different lengths between samples, define the template using the longest possible length of each feature. Every feature annotated must be covered by the sequencing data, and no feature can span the exact middle of the template sequence when using paired end data.",required=True)
cmdLineArgParser.add_argument("-inputFasta", dest="inputFasta", help="FASTA file of sequences from which we need to extract and map barcodes. ",required=True)
cmdLineArgParser.add_argument("-outputDir", dest="outputDir", help="Directory where output files should be saved",required=True)


cmdLineArgParser.add_argument("-fasta5PrimeTrimLength", dest="fasta5PrimeTrimLength", default=0,  help="Number of bp to trim from the 5' end of each fasta sequence.")
cmdLineArgParser.add_argument("-fasta3PrimeTrimLength", dest="fasta3PrimeTrimLength", default=0,  help="Number of bp to trim from the 3' end of each fasta sequence.")
cmdLineArgParser.add_argument("-blastPath", dest="blastPath", help="BLAST installation directory if it is not in the Path already", default="")




###########################################################################
## Utility functions
###########################################################################


## Initializer for lock for multiprocessing
  
def init(l):
	global lockArray
	lockArray = l


## Print to std error

def eprint(*args, **kwargs):
	print(*args, file=sys.stderr, **kwargs)

def getBestBlastMatch(blastOutputLocal):
	bestMatch = []
	currentBestEValue = 1
	blastOutputArray = blastOutputLocal
	if(len(blastOutputArray)==0): #if there are no hits, return empty array
		return bestMatch
	splitInfo = blastOutputArray[0].split("\t")
	if(len(splitInfo)<10): #if the line is poorly formatted, return empty array
		return bestMatch
	currentBestEValue = float(splitInfo[10])
	bestMatch = [splitInfo[1]]
	bestMatch.extend(list(map(int,splitInfo[6:10])))
	if(len(blastOutputArray)==1): #if there is only one hit, return it
		return bestMatch
	splitInfo = blastOutputArray[1].split("\t")
	if(currentBestEValue < float(splitInfo[10])): #if the first hit is better than the second, return it
		return bestMatch
	return "multiple" #there are multiple hits!


	
## Extract coordinates of blast match dealing with reverse complemented sequences if necessary

def getSubjectMatchCoordinates(topBlastResult):
	topBlastResultInts = [topBlastResult[0]]
	for x in topBlastResult[1:len(topBlastResult)]:
		topBlastResultInts.append(int(x))
	startingCoor = topBlastResultInts[1]
	endingCoor = topBlastResultInts[2]
	rev = False
	if(topBlastResultInts[3]<topBlastResultInts[4]): #forward orientation
		startingCoor = startingCoor - topBlastResultInts[3]
		endingCoor = endingCoor + templateSeqLengthsDict[topBlastResultInts[0]] - topBlastResultInts[4]
	else:
		rev = True
		startingCoor = startingCoor - templateSeqLengthsDict[topBlastResultInts[0]] + topBlastResultInts[3]-1
		endingCoor = endingCoor + topBlastResultInts[4]-1
	return [startingCoor, endingCoor, rev]

	
###########################################################################	
## Functions for Parsing Input Files and Directories
###########################################################################

## Read Template sequence provided by user and parse. 
#  This code works best if every UMI/Index/Barcode is only in a single read, so reads are effectively non-overlapping. 
#  Use -readLength to truncate the read if necessary			
			
def parseTemplateSeq():
	sequence = ""
	with open(args.templateSeqFile) as infile:
		sequence = infile.readline().strip()
	if(len(re.sub("[ACGTacgtXUDNn]","",sequence))>0): # if the sequence has disallowed characters, quit
		eprint("Template sequence has illegal characters!\n")
		sys.exit(0)
	#if it is paired end, split template using readSize, 
	templateArray = []
	templateArray.append(sequence)
	global expectedBarcodeLength	
	expectedBarcodeLength = sequence.count("X")
	#collapse non-constant features into single character and add to global variable
	global templateSeqArray
	
	for seq in templateArray:
		seq = re.sub("D+","\tD\t",seq)
		seq = re.sub("U+","\tU\t",seq)
		seq = re.sub("X+","\tX\t",seq)
		seq = re.sub("\t\t","\t",seq)
		seq = re.sub("\t\t","\t",seq)
		seq = re.sub("\t\t","\t",seq)
		seq = re.sub("^\t","",seq)
		seq = re.sub("\t$","",seq)
		templateSeqArray.append(seq.split("\t"))
	
	global templateSeqLengthsArray
	for seqNum in range(0,len(templateArray)):
		seq = templateArray[seqNum]
		seqArray = templateSeqArray[seqNum]
		seqLengthsArray = []
		lastValidIdex = 0
		for i in range(0,len(seqArray)):
			if(not seqArray[i] in validFeatureCounts.keys()):
				seqLengthsArray.append(-1)
				continue
			startIdex = -1
			for j in range(lastValidIdex,len(seq)):
				if seq[j] == seqArray[i] and startIdex == -1:
					startIdex = j
					continue
				if(startIdex >= 0 and seq[j] != seqArray[i]):
					seqLengthsArray.append(j-startIdex)
					lastValidIdex = j
					break
				if(j==len(seq)-1):
					seqLengthsArray.append(len(seq)-startIdex)
					break
		templateSeqLengthsArray.append(seqLengthsArray)
	# print(templateArray)
		
## Figure out which fastq files we are going to use, 
#  Pair forward and reverse reads as necessary, assume they are in alphabetical order (R1 before R2)
# create blank output files

	
## Extract constant regions in template array, creates fasta file and blast database for each, then make a master database with all constant regions and multiplexing primer sequences

def createConstRegionFasta():
	readNumber = 0
	filenames = []
	for seqArray in templateSeqArray:
		readNumber = readNumber + 1
		seqNumber = 0
		constRegionFilenameArray = []
		constRegionNameArray = []
		for seq in seqArray:
			if(len(seq)>1):
				seqNumber = seqNumber+1
				filePrefix = "const_region_"+str(readNumber)+"_"+str(seqNumber)
				fileString = args.outputDir+"."+filePrefix+".fasta"
				with open(fileString,"w") as outfile:
					outfile.write(">const_region_"+str(readNumber)+"_"+str(seqNumber)+"\n")
					outfile.write(seq+"\n")
				constRegionFilenameArray.append(fileString)
				constRegionNameArray.append(filePrefix)
				filenames.append(fileString)
				subprocess.call([args.blastPath+"makeblastdb","-in",fileString,"-dbtype","nucl"])
			else:
				constRegionFilenameArray.append(None)
				constRegionNameArray.append(None)
		global constantRegionFastaFilenames
		constantRegionFastaFilenames.append(constRegionFilenameArray)
		global constantRegionNames
		constantRegionNames.append(constRegionNameArray)

	with open(args.outputDir+allConstRegionsFileName, 'w') as outfile:
		for fname in filenames:
			with open(fname) as infile:
				seqName = ""
				for line in infile:
					if line[0:1] == ">":
						seqName = line[1:(len(line)+1)]
					else:
						templateSeqLengthsDict[seqName.strip()]=len(line.strip())
					outfile.write(line)
	blastCall = [args.blastPath+"makeblastdb","-in",args.outputDir+allConstRegionsFileName,"-dbtype","nucl"]
	subprocess.call(blastCall)
	

###########################################################################
## Extract barcodes from fasta file
########################################################################### 


def extractRegionsFromFasta():
	# make a fasta file from all reads we are processing and blast against database of all index and constant regions
	
	filePrefix = os.path.splitext(os.path.basename(args.inputFasta))[0]
	print(filePrefix)
	
	# blast reads against constant and multiplexing index sequences
	blastCommand = [args.blastPath+"blastn","-query",args.inputFasta,"-db",args.outputDir+allConstRegionsFileName]
	blastCommand.extend(constantRegionsBlastParams)
	blastResult = subprocess.check_output(blastCommand).decode('ascii').rstrip().split("\n") 
	finalReturnVal = []
	notConstRegionRegex = re.compile("^((?!const_region).)*$")
	readDict = {}
	global templateSeqLengthsArray
	global templateSeqArray
	readNum = 0
	for line in blastResult: #store all blast hits in a dictionary for quick lookup
		mySplit = line.split("\t")
		curSample = mySplit[0]
		if curSample not in readDict:
			readDict[curSample]=[]
		readDict[curSample].append(line)
	readID = 0
	with open(args.inputFasta) as inputFastaHandle, open(args.outputDir+filePrefix+"_barcode.fasta","w") as outputFileHandle:
		barcodeSeqRecords = []
		for read in SeqIO.parse(inputFastaHandle, "fasta"):
			readID +=1
			startingCoordinates = [None]*(len(templateSeqArray[readNum])+1)
			myReadKey = read.id
			foundBarcode = ""
			if (myReadKey not in readDict):
				continue
			readBlastResult=readDict[myReadKey] #get the blast result lines corresponding to this read
			
			blastLocationDict = {}
	
			for line in readBlastResult: #store all blast hits in a dictionary for quick lookup
				mySplit = line.split("\t")
				curSample = mySplit[1]
				if curSample not in blastLocationDict:
					blastLocationDict[curSample]=[]
				blastLocationDict[curSample].append(line)
			
			prevSegmentStartingCoord = -1
			reversedRead = False
			firstIndex = -1
			goodCoords = [0]*(len(templateSeqArray[readNum])+1)
			for i in range(0,len(templateSeqArray[readNum])): #for each feature in the template
				if(templateSeqArray[readNum][i]=="D" or (templateSeqArray[readNum][i]!="U" and templateSeqArray[readNum][i]!="X")): #if this is an indexing barcode location or a constant region
					myLocalHits = []
					topBlastResult = ""
					if(templateSeqArray[readNum][i]=="D"): # if this is a multiplexing index region
						myLocalHits = list(filter(notConstRegionRegex.match, readBlastResult))
						topBlastResult = getBestBlastMatch(myLocalHits) #get the best hitting indexing region
					else: #this is a constant region
						if constantRegionNames[readNum][i] not in blastLocationDict:
							continue
						myLocalHits = blastLocationDict[constantRegionNames[readNum][i]] #get blast hits for this specific constant region
						topBlastResult = getBestBlastMatch(myLocalHits)
					
					if(topBlastResult == [] or topBlastResult == "multiple"): #if we don't have a good match for this region
						continue
					
					if(firstIndex == -1):
						firstIndex = i
					#figure out where in the read this index region is hitting, set coordinates and track the first region we are mapping to account for possibly needing to reverse the match location
					matchCoords = getSubjectMatchCoordinates(topBlastResult)
					
					
					if(prevSegmentStartingCoord > matchCoords[0] and not reversedRead):
						reversedRead = True
					
					if(prevSegmentStartingCoord == -1): #if this is the first segment we have found a hit for, figure out the right index where the segment is
						prevSegmentStartingCoord = matchCoords[0]
					if (not reversedRead): #if the read is not reversed, add in the coordinates properly
						startingCoordinates[i]=matchCoords[0]
						startingCoordinates[i+1]=matchCoords[1]
					else:
						if(firstIndex >=0): #if it is reversed and this is not the first segment we have hit, assume the previous segment we hit needs to have its indices swapped
							tmpVal = startingCoordinates[firstIndex]
							startingCoordinates[firstIndex] = startingCoordinates[firstIndex+1]
							startingCoordinates[firstIndex+1] = tmpVal
							firstIndex = -2
						startingCoordinates[i]=matchCoords[1]
						startingCoordinates[i+1]=matchCoords[0]
					goodCoords[i]=1
					goodCoords[i+1]=1
					
					if(templateSeqArray[readNum][i]=="D"):
						identifiedIndexBCs.append(topBlastResult[0])
			
			if(not reversedRead and startingCoordinates[0] == None): #put the 0 in the right place depending on if the read is reversed or not relative to the template if we haven't found it already
				startingCoordinates[0] = 0
			if(reversedRead and startingCoordinates[len(startingCoordinates)-1] == None):
				startingCoordinates[len(startingCoordinates)-1] = 0
				
			if(reversedRead and startingCoordinates[0] == None): #set the end of the read to be readLength in the right place depending on if the read is reversed or not relative to the template and if we haven't found it already
				startingCoordinates[0] = len(read.seq)
			if(not reversedRead and startingCoordinates[len(startingCoordinates)-1] == None):
				startingCoordinates[len(startingCoordinates)-1] = len(read.seq)
			
			if(0 in goodCoords):
				for i in range(0,len(templateSeqArray[readNum])): #use expected length of features to fill in missing coordinates, templated off of mapped coordinates if possible
					if(templateSeqArray[readNum][i] in ["X"] and startingCoordinates[i+1] is None and not startingCoordinates[i] is None and i in goodCoords):
						startingCoordinates[i+1] = startingCoordinates[i] + templateSeqLengthsArray[readNum][i]
					elif(templateSeqArray[readNum][i] in ["X"] and startingCoordinates[i] is None and not startingCoordinates[i+1] is None and (i+1) in goodCoords):
						startingCoordinates[i] = startingCoordinates[i+1] - templateSeqLengthsArray[readNum][i]
					elif(templateSeqArray[readNum][i] in ["X"] and startingCoordinates[i+1] is None and not startingCoordinates[i] is None):
						startingCoordinates[i+1] = startingCoordinates[i] + templateSeqLengthsArray[readNum][i]
					else:
						continue
			if(readID <= 10):
				print(read.id)
				print(read.seq)
				print(templateSeqArray[0])
				print(startingCoordinates)
			for i in range(0,len(templateSeqArray[readNum])): #now that we have all the coordinates, let us extract the sequences for each template feature
				#set the end coordinate of this feature properly
				if(startingCoordinates[i] == None or startingCoordinates[i+1] == None):
					continue
				start = min(startingCoordinates[i], startingCoordinates[i+1]) 
				end = max(startingCoordinates[i], startingCoordinates[i+1])
				maxLen = len(read.seq)
				if(end > maxLen):
					end = maxLen
				
				if(templateSeqArray[readNum][i]=="X"):#extract coordinates of any BC region that exist
					mybc = read.seq[start:end]
					if(reversedRead):
						mybc = mybc.reverse_complement()
					if(readID <= 10):
						print(str(i)+" "+str(start)+" "+str(end)+" "+ mybc)
					if(len(mybc)>0):
						foundBarcode = foundBarcode + mybc
			barcodeSeqRecords.append(SeqRecord(foundBarcode,id=read.id, name = "", description = ""))
		SeqIO.write(barcodeSeqRecords,outputFileHandle,"fasta")

	
###########################################################################
## Run Program
###########################################################################



## Call Initialization functions to parse user inputs
args = cmdLineArgParser.parse_args()
parseTemplateSeq()
createConstRegionFasta()

global templateSeqLengthsArray
global templateSeqArray
print(templateSeqArray)
print(templateSeqLengthsArray)

extractRegionsFromFasta()


